import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

# --- 1. APP CONFIGURATION ---
# Sets the page title and layout to 'wide' to accommodate side-by-side charts.
st.set_page_config(page_title="PSEO Earnings & Flows Dashboard", layout="wide")

# --- 2. GLOBAL STYLING (High Contrast) ---
# Enforces a strict black-on-white color scheme for accessibility and readability.
# This overrides default Streamlit themes that might be too low-contrast for some users.
st.markdown("""
<style>
    .stApp { background-color: white; color: black; }
    /* Force all text elements (headers, paragraphs, labels) to be black */
    h1, h2, h3, h4, h5, h6, p, label, .stRadio, .stMultiSelect, div {
        color: black !important; 
        font-family: 'Helvetica', sans-serif;
    }
    /* Padding adjustments for a cleaner look */
    .block-container {padding-top: 2rem; padding-bottom: 2rem;}
</style>
""", unsafe_allow_html=True)

# --- 3. DATA LOADING FUNCTIONS ---

@st.cache_data
def load_earnings_data(mode):
    """
    Loads the earnings data based on the user's selected mode (All Cohorts vs. Trends).
    
    Args:
        mode (str): 'All Cohorts' loads the aggregate baseline (Agg Level 28).
                    'Trends' loads the cohort-specific data (Agg Level 34).
    
    Returns:
        pd.DataFrame: A cleaned dataframe with mapped Degree and Major labels.
    """
    if mode == "All Cohorts":
        # Load the Foundation file (Agg Level 28 - All Time Aggregate)
        df = pd.read_csv('state_foundation_all_years.csv', dtype={'cipcode': str, 'degree_level': str})
        df['Cohort Group'] = 'All Cohorts' 
    else:
        # Load the Trends file (Agg Level 34 - By Graduation Year)
        df = pd.read_csv('state_cohort_trends.csv', dtype={'cipcode': str, 'degree_level': str})
    
    # Map CIP Codes to Readable Major Families
    def get_major_family(code):
        if str(code).startswith('13'): return 'Education'
        if str(code).startswith('11'): return 'CompSci / AI'
        return 'Other'
    
    if 'Major Family' not in df.columns:
        df['Major Family'] = df['cipcode'].apply(get_major_family)

    # Map Degree Codes (e.g., '05') to Labels (e.g., "Bachelor's")
    degree_map = {
        '01': 'Certificate <1yr', '02': 'Certificate 1-2yrs',
        '03': 'Associates', '05': 'Bachelor\'s',
        '07': 'Master\'s', '17': 'Doctoral'
    }
    df['Degree Label'] = df['degree_level'].astype(str).map(degree_map).fillna(df['degree_level'])
    
    # Filter strictly for our target majors
    return df[df['Major Family'].isin(['Education', 'CompSci / AI'])]

@st.cache_data
def load_flow_data():
    """
    Loads the processed Industry Flow data.
    
    This dataset tracks the movement of graduates from their degree (Source) 
    to the economic sector of their employment (Target).
    
    Returns:
        pd.DataFrame: A clean dataframe containing State, Industry, and Graduate Counts.
    """
    # Load the cleaned flows file. 
    # Note: 'pseo_flows_dashboard_ready.csv' must be generated by the cleaning pipeline.
    df = pd.read_csv('pseo_flows_dashboard_ready.csv', dtype={'cipcode': str, 'degree_level': str})
    
    # Map Major Names for the Sankey Diagram Nodes
    df['Major Name'] = df['cipcode'].apply(lambda x: 'Education' if str(x).startswith('13') else 'CompSci / AI')
    
    # Map Degree Labels
    degree_map = {
        '01': 'Certificate <1yr', '02': 'Certificate 1-2yrs',
        '03': 'Associates', '05': 'Bachelor\'s',
        '07': 'Master\'s', '17': 'Doctoral'
    }
    df['Degree Label'] = df['degree_level'].astype(str).map(degree_map).fillna(df['degree_level'])

    return df

# --- 4. SIDEBAR CONTROLS (SHARED) ---
st.sidebar.header("Global Controls")

# A. Cohort Selector (Primarily for Earnings Tab)
cohort_options = [
    'All Cohorts', 
    '2001-2003', '2004-2006', '2007-2009', 
    '2010-2012', '2013-2015', '2016-2018', '2019-2021'
]
selected_cohort = st.sidebar.selectbox("Graduation Cohort (Earnings Only)", cohort_options)

# B. Timeframe Selector (Used by BOTH Tabs)
# Determines whether we look at outcomes 1, 5, or 10 years after graduation.
timeframe_label = st.sidebar.radio(
    "Select Timeframe",
    options=['1 Year Post-Grad', '5 Years Post-Grad', '10 Years Post-Grad'],
    index=0
)
# Map label to dataset column prefixes (e.g., 'y1')
time_code = {'1 Year Post-Grad': 'y1', '5 Years Post-Grad': 'y5', '10 Years Post-Grad': 'y10'}[timeframe_label]

st.sidebar.markdown("---")

# C. Degree Level Filter (Shared)
selected_degrees = st.sidebar.multiselect(
    "Select Degree Level(s)",
    ['Certificate <1yr', 'Associates', 'Bachelor\'s', 'Master\'s', 'Doctoral'],
    default=['Bachelor\'s', 'Master\'s']
)

# D. Major Filter (Shared)
selected_majors = st.sidebar.multiselect(
    "Select Major(s)",
    ['Education', 'CompSci / AI'],
    default=['Education', 'CompSci / AI']
)

# Validation: Ensure user selects at least one option
if not selected_degrees or not selected_majors:
    st.error("Please select at least one Degree Level and one Major.")
    st.stop()

# --- 5. MAIN DASHBOARD TABS ---
# We split the analysis into two distinct views: Earnings (ROI) and Flows (Career Pathways).
tab1, tab2 = st.tabs(["ðŸ’° Earnings Analysis", "ðŸ”„ Industry Flows"])

# ==========================================
# TAB 1: EARNINGS ANALYSIS (Your Existing Code)
# ==========================================
with tab1:
    # 1. Load Data based on Cohort selection
    if selected_cohort == "All Cohorts":
        df = load_earnings_data("All Cohorts")
    else:
        raw_df = load_earnings_data("Trends")
        # Filter for the specific cohort bucket
        df = raw_df[raw_df['Cohort Group'] == selected_cohort].copy()

    # 2. Filter Data
    mask = (df['Degree Label'].isin(selected_degrees)) & (df['Major Family'].isin(selected_majors))
    filtered_df = df[mask]

    if filtered_df.empty:
        st.warning(f"No earnings data available for {selected_cohort} with these filters.")
    else:
        # 3. Aggregate Data (Mean of State Medians)
        # We calculate the average earnings across all available states for the selected group.
        cols_to_use = [f'{time_code}_p25_earnings', f'{time_code}_p50_earnings', f'{time_code}_p75_earnings']
        agg_df = filtered_df.groupby(['Major Family', 'Degree Label'])[cols_to_use].mean().reset_index()

        # 4. Reshape for Plotly (Wide to Long format)
        plot_data = agg_df.melt(
            id_vars=['Major Family', 'Degree Label'],
            value_vars=cols_to_use,
            var_name='Metric',
            value_name='Earnings'
        )

        # Map metric names to user-friendly labels
        metric_map = {
            f'{time_code}_p25_earnings': '25th Percentile (Entry)', 
            f'{time_code}_p50_earnings': '50th Percentile (Median)', 
            f'{time_code}_p75_earnings': '75th Percentile (Top Tier)'
        }
        plot_data['Percentile'] = plot_data['Metric'].map(metric_map)

        # 5. Visualization
        st.header("Comparative Earnings Analysis")
        st.markdown(f"**Cohort:** {selected_cohort} â€¢ **Timeframe:** {timeframe_label}")

        facet_col_arg = "Major Family" if len(selected_majors) > 1 else None

        fig = px.bar(
            plot_data,
            x="Degree Label",
            y="Earnings",
            color="Percentile",
            facet_col=facet_col_arg,
            barmode="group",
            category_orders={
                "Degree Label": ['Certificate <1yr', 'Associates', 'Bachelor\'s', 'Master\'s', 'Doctoral'], 
                "Percentile": ['25th Percentile (Entry)', '50th Percentile (Median)', '75th Percentile (Top Tier)']
            },
            color_discrete_map={
                '25th Percentile (Entry)': '#A8DADC',      
                '50th Percentile (Median)': '#457B9D',     
                '75th Percentile (Top Tier)': '#1D3557'    
            },
            height=600,
        )

        # 6. Styling (High Contrast & Readability)
        fig.update_traces(texttemplate='%{y:$.2s}', textposition='outside')

        fig.update_xaxes(
            title_text="", showline=True, linewidth=2, linecolor='black',
            tickfont=dict(size=14, color='black'), matches='x'
        )

        fig.update_yaxes(
            title_text="Annual Earnings ($)", 
            title_font=dict(size=14, color="black", weight="bold"),
            showgrid=True, gridcolor="#888888", gridwidth=1,
            dtick=20000, tickformat="$,.0f",
            tickfont=dict(size=12, color="black", weight="bold"),
            linecolor='black', linewidth=2, matches='y'
        )

        fig.update_layout(
            plot_bgcolor="white", paper_bgcolor="white",
            font=dict(color="black", family="Helvetica"),
            legend=dict(orientation="h", y=-0.15, x=0.5, title=""),
            margin=dict(t=60, l=50, r=50, b=100)
        )

        # Fix facet labels
        fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1], font=dict(size=20, color="black", weight="bold")))

        # Add vertical divider if comparing
        if len(selected_majors) > 1:
            fig.add_shape(type="line", x0=0.5, y0=0, x1=0.5, y1=1, xref="paper", yref="paper", line=dict(color="black", width=1, dash="dot"))

        st.plotly_chart(fig, use_container_width=True)

        # 7. Summary Table
        st.markdown("### ðŸ”¢ Detailed Data Table")
        display_table = agg_df.copy().rename(columns=metric_map)
        st.dataframe(display_table.style.format("${:,.0f}", subset=list(metric_map.values())), use_container_width=True)


# ==========================================
# TAB 2: INDUSTRY FLOW ANALYSIS (New Feature)
# ==========================================
with tab2:
    st.header("ðŸŽ“ Career Pathways Analysis")
    st.write("This Sankey diagram visualizes the flow of graduates from their academic programs (Left) to their sector of employment (Right).")

    # Load Flow Data
    flow_df = load_flow_data()

    # 1. Tab-Specific Controls (Geography)
    # Allows filtering flows by a specific state to analyze geographic retention or local industry needs.
    col_filter, col_spacer = st.columns([1, 2])
    with col_filter:
        # Get list of available states sorted alphabetically
        state_list = sorted(flow_df['state_name'].dropna().unique().tolist())
        selected_state = st.selectbox("Select Geography (Flow Only)", ["All States"] + state_list)

    # 2. Filter Logic
    # Apply global filters (Degree, Major) + local filter (State)
    mask_flow = (flow_df['Degree Label'].isin(selected_degrees)) & \
                (flow_df['Major Name'].isin(selected_majors))
    
    if selected_state != "All States":
        mask_flow &= (flow_df['state_name'] == selected_state)
    
    filtered_flow = flow_df[mask_flow].copy()

    # 3. Determine Flow Column
    # Selects the correct count column based on the global Timeframe selection (y1, y5, or y10)
    flow_col = f'{time_code}_grads_emp'

    if filtered_flow.empty or filtered_flow[flow_col].sum() == 0:
        st.warning(f"No flow data available for {selected_state} with current filters.")
    else:
        # 4. Aggregate for Sankey
        # We sum graduates by (Major -> Industry). This simplifies the visual by removing Degree distinctions
        # in the chart itself, though the data is filtered by the selected degrees.
        agg_flow = filtered_flow.groupby(['Major Name', 'industry_name'])[flow_col].sum().reset_index()
        
        # Remove empty flows (0 graduates) to keep the chart clean
        agg_flow = agg_flow[agg_flow[flow_col] > 0]

        # 5. Create Nodes and Links for Plotly
        # Plotly requires numeric indices for Source and Target nodes.
        
        # List all unique labels (Majors + Industries)
        all_nodes = list(agg_flow['Major Name'].unique()) + list(agg_flow['industry_name'].unique())
        node_map = {label: i for i, label in enumerate(all_nodes)}

        # Map the labels to their numeric IDs
        source_ids = agg_flow['Major Name'].map(node_map)
        target_ids = agg_flow['industry_name'].map(node_map)
        values = agg_flow[flow_col]

        # 6. Visualization (Sankey Diagram)
        fig_sankey = go.Figure(data=[go.Sankey(
            node=dict(
                pad=15,
                thickness=20,
                line=dict(color="black", width=0.5),
                label=all_nodes,
                color="#457B9D"  # Consistent blue theme
            ),
            link=dict(
                source=source_ids,
                target=target_ids,
                value=values,
                color="rgba(168, 218, 220, 0.5)"  # Transparent Light Blue for flows
            )
        )])

        fig_sankey.update_layout(
            title_text=f"Employment Flows: {selected_state} ({timeframe_label})",
            font=dict(size=14, color="black"),
            plot_bgcolor="white",
            paper_bgcolor="white",
            height=600
        )

        st.plotly_chart(fig_sankey, use_container_width=True)

        # 7. Flow Summary
        st.markdown("### ðŸ“‹ Top Industries")
        top_industries = agg_flow.groupby('industry_name')[flow_col].sum().sort_values(ascending=False).head(10)
        st.bar_chart(top_industries)